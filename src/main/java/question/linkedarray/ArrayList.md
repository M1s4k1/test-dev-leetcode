### 数组题目的技巧

#### 双指针

##### 快慢指针

原地修改数组(leetcode_26):

> **数组问题中比较常见的快慢指针技巧，是让你原地修改数组**。
>
>
> 给定一个升序数组, 要求原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序 应该保持 一致
>
> 原地修改的要求就是,不允许 new 新数组，只能在原数组上操作
> 
> 由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。但如果毎找到一个重复元素就立即原地删除它，由于数组中删除元素涉及数据搬移，整个时间复杂度是会达到 O(N^2)。
> 
>高效解决这道题就要用到快慢指针技巧：
>
> 我们让慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不重复的元素就赋值给 slow 并让 slow 前进一步。
>
> 这样，就保证了 nums[0..slow] 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组去重之后的结果。
> 
> 可以发现,这个思路和有序链表的删除思路相同
>


移除元素(leetcode_27):

> 给定一个升序数组, 要求原地删除给定的元素
>
> 与26题思路一模一样, 双指针同时开始从头遍历
> 如果快指针与给定值相同,快指针移动,慢指针停止
> 如果快指针与给定值不同,慢指针移动,并赋值为快指针的值,快指针移动
>


移动零(leetcode_283):

> 给定一个数组 nums，将所有0移动到数组的末尾，同时保持非0元素的相对顺序
>
> 不要直接去向移动0值的位置
> 将前面的0删除,后面重新赋值为0,最后额结果是一致的, 而这就又转换成了原地删除的题目
> 
> 如果快指针与0,快指针移动,慢指针停止
> 如果快指针与0不同,慢指针移动,并赋值为快指针的值,快指针移动
> 当快指针遍历完毕,慢指针移动,并将后面位置的值都置为0
> 






