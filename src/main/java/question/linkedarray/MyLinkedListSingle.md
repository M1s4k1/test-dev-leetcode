### 单向题目的技巧

#### 双指针

##### 拉链法

合并两个有序链表(leetcode_21):

> **这是最基本的链表技巧**。
>
>
> 给定两个有序链表,合并为一个有序链表
>
> 从头开始同时遍历两个链表,每次取两个当前节点中的小值
> 大值的节点不移动,小值的节点向后移动
> 再次比较两个节点,循环直到短链表的终点
>
> 这道题的思路不难.形象的理解,两个遍历原有数组的指针类似拉链的两个齿.新链表的指针就好像拉链的拉索，将两个有序链表合并
>
>代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧,使用虚拟头节点会省去很多对空指针的处理


单链表的分解(leetcode_86):

> **拉链法的反向使用**。
>
>
> 给定一个链表的头节点head和一个特定值x，要求对链表进行分隔，使得所有小于x的节点都出现在大于或等于x 的节点之前
>
> 我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 x，另一个链表中的元素都大于等于 x，最后再把这两条链表接到一起，就得到了题目想要的结果。
>
> 这道题除了虚拟头节点的技巧外,还要注意将大链表接到小链表后,操作大链表尾节点.next=null
> 原链表遍历结束后,尾节点如果分配到小链表中,则大链表的尾节点没有指向null, 会造成链表成环
>

删除链表的倒数第 N 个节点(leetcode_19):

> 双指针,前后指针固定间隔
>
>
> 这个技巧中,让快慢指针保持相同的间距
>
> 一次遍历中得到删除链表的倒数第 N 个节点. 快指针先开始移动,前进N步后,慢指针开始移动
> 以链表长度为l,当快指针到达尾null节点时,停在正数第l+1个节点
> 此时慢指针前进了l-N步, 位置在 l-N 节点位置,即倒数N的节点位置
>
> 对于题目,没有虚拟头节点,且都以1为起始, 第x个节点,就是倒数l-x+1个节点
> 从开始移动, 指针走y步, 在正数第1+y的位置, 在倒数l-(1+y)+1 =l-y个节点
> 我们需要得到倒数N个节点,就是N=l-y, 需要指针走y=l-N步
>
> 这道题目就是节点的位置计数比较烦,特殊点注意虚拟头节点, 删除操作需要使用前一个节点, 不使用虚拟头节点的话,如果是删除的是正数第一个节点就会空指针.
>


环形链表(leetcode_141):

> 双指针,前后指针倍数步长(速度)
>
>
> 这个技巧中,让快慢指针保持固定的速度比
>
> 对于环形链表的画图表示,可以直接参考题目,很形象. 我们直接把环形链表想象成学校的操场.未进入换的节点看做, 操场大门到跑道的部分
>
> 两个有速度差的人,开始进入操场跑步,操场大门到跑道的部分其实无所谓.最终都会进入跑道开始画圈
> 如果跑道是个直线,速度快的同学最终肯定会到达终点, 即快指针遍历到尾null节点
> 如果跑道是圆, 速度快的同学一定会领先慢同学一圈, 即快慢指针相遇
>
> 只要两个指针有速度差即可, 这里让快指针是慢指针速度的两倍
>



链表中间节点(leetcode_876):

> 双指针,前后指针倍数步长(速度),同上
>
>
> 偶数长度链表,快指针是慢指针两倍速,慢指针到达中间节点
> 奇数长度链表,快指针到尾null节点,慢指针在 (链表长度+1)/2 的节点,正好是两个中间结点中的第二个中间结点
> 没啥可细说的
>



环形链表II(leetcode_142):

> 双指针,前后指针倍数步长(速度),同上
>
> 这道题的难点在于返回环起点
>
> 链表不成环的情况不需要讨论
> 链表成环其情况下,慢指针速度为k,快指针速度2k,当两个指针相遇时:
> 慢指针前进k步,快指针前进2k步, 距离差2k-k=k (未入环的部分被对应减去), 剩下的k就是快指针在环内领先了慢指针然后相遇,k为环长度的整数倍
> 把从环起点到相遇点,距离做为m, 慢指针一共走了k, 链表头节点到环起点为k-m, 慢指针重置到头节点,每次一步,前进k-m步,会到达环起点
> k为环长度的整数倍,m一定小于环长, 相遇点距环起点为k-m, 每次一步,快指针前进k-m步,会到达环起点
> 快慢指针下一次会在环起点相遇
>
> 这道题自己真想不出来,记住这种做法吧
> 

