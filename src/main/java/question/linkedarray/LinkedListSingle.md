### 单向题目的技巧

#### 双指针

##### 拉链法



合并两个有序链表(leetcode_21):

> **这是最基本的链表技巧**。
>
>
> 给定两个有序链表,合并为一个有序链表
>
> 从头开始同时遍历两个链表,每次取两个当前节点中的小值
> 大值的节点不移动,小值的节点向后移动
> 再次比较两个节点,循环直到短链表的终点
>
> 这道题的思路不难.形象的理解,两个遍历原有数组的指针类似拉链的两个齿.新链表的指针就好像拉链的拉索，将两个有序链表合并
>
>代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧,使用虚拟头节点会省去很多对空指针的处理


单链表的分解(leetcode_86):

> **拉链法的反向使用**。
>
>
> 给定一个链表的头节点head和一个特定值x，要求对链表进行分隔，使得所有小于x的节点都出现在大于或等于x 的节点之前
>
> 我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 x，另一个链表中的元素都大于等于 x，最后再把这两条链表接到一起，就得到了题目想要的结果。
>
> 这道题除了虚拟头节点的技巧外,还要注意将大链表接到小链表后,操作大链表尾节点.next=null
> 原链表遍历结束后,尾节点如果分配到小链表中,则大链表的尾节点没有指向null, 会造成链表成环
>


删除链表的倒数第 N 个节点(leetcode_19):

> 双指针,前后指针固定间隔
>
>
> 这个技巧中,让快慢指针保持相同的间距
>
> 一次遍历中得到删除链表的倒数第 N 个节点. 快指针先开始移动,前进N步后,慢指针开始移动
> 以链表长度为l,当快指针到达尾null节点时,停在正数第l+1个节点
> 此时慢指针前进了l-N步, 位置在 l-N 节点位置,即倒数N的节点位置
>
> 对于题目,没有虚拟头节点,且都以1为起始, 第x个节点,就是倒数l-x+1个节点
> 从开始移动, 指针走y步, 在正数第1+y的位置, 在倒数l-(1+y)+1 =l-y个节点
> 我们需要得到倒数N个节点,就是N=l-y, 需要指针走y=l-N步
>
> 这道题目就是节点的位置计数比较烦,特殊点注意虚拟头节点, 删除操作需要使用前一个节点, 不使用虚拟头节点的话,如果是删除的是正数第一个节点就会空指针.
>


环形链表(leetcode_141):

> 双指针,前后指针倍数步长(速度)
>
>
> 这个技巧中,让快慢指针保持固定的速度比
>
> 对于环形链表的画图表示,可以直接参考题目,很形象. 我们直接把环形链表想象成学校的操场.未进入换的节点看做, 操场大门到跑道的部分
>
> 两个有速度差的人,开始进入操场跑步,操场大门到跑道的部分其实无所谓.最终都会进入跑道开始画圈
> 如果跑道是个直线,速度快的同学最终肯定会到达终点, 即快指针遍历到尾null节点
> 如果跑道是圆, 速度快的同学一定会领先慢同学一圈, 即快慢指针相遇
>
> 只要两个指针有速度差即可, 这里让快指针是慢指针速度的两倍
>


链表中间节点(leetcode_876):

> 双指针,前后指针倍数步长(速度),同上
>
>
> 偶数长度链表,快指针是慢指针两倍速,慢指针到达中间节点
> 奇数长度链表,快指针到尾null节点,慢指针在 (链表长度+1)/2 的节点,正好是两个中间结点中的第二个中间结点
> 没啥可细说的
>


环形链表II(leetcode_142):

> 双指针,前后指针倍数步长(速度),同上
>
> 这道题的难点在于返回环起点
>
> 链表不成环的情况不需要讨论
> 链表成环其情况下,慢指针速度为k,快指针速度2k,当两个指针相遇时:
> 慢指针前进k步,快指针前进2k步, 距离差2k-k=k (未入环的部分被对应减去), 剩下的k就是快指针在环内领先了慢指针然后相遇,k为环长度的整数倍
> 把从环起点到相遇点,距离做为m, 慢指针一共走了k, 链表头节点到环起点为k-m, 慢指针重置到头节点,每次一步,前进k-m步,会到达环起点
> k为环长度的整数倍,m一定小于环长, 相遇点距环起点为k-m, 每次一步,快指针前进k-m步,会到达环起点
> 快慢指针下一次会在环起点相遇
>
> 这道题自己真想不出来,记住这种做法吧
>


相交链表(leetcode_160):

> 确保链表无环,判断两个链表是否相交, 双指针技巧,这道题有多种解法
> 
> 相交的核心点: 两个指针同时遍历到相交点,或者同时遍历到尾null节点 --> 凑出两个链表长度相同
> A1: 个人思路
> 先遍历, 获得两个链表的长度, 补齐短链表长度至和长链表相同, 开始双指针遍历
> 
> A2: 教程思路
> 使短链表尾部和长链表头部相连,  使长链表尾部和短链表头部相重复
> 如果重复:
>   A单独节点 -> 重复节点 -> B单独节点 -> 重复节点
>   B单独节点 -> 重复节点 -> A单独节点 -> 重复节点
> 前三部分可以保证长度相同, 则双指针会同时遍历到重复节点, 获得相交节点
> 如果不重复
>   A节点 -> B节点
>   B节点 -> A节点
> 同时遍历到尾null节点
> 
> A3:教程思路3
> 遍历任一链表,到尾部后与另一链表头节点相连, 这道题就转变为了环形链表II(leetcode_142):
>
>


删除排序链表重复元素(leetcode_83):

> 这道题比较简单
>
> 已排序的链表,双指针同时开始从头遍历
> 如果快指针和慢指针值相同,快指针移动,慢指针停止
> 如果快指针和慢指针值不同,慢指针next指向快指针,快慢指针都移动
>
> 设计到 修改/删除 操作,注意虚拟头节点的使用
>

反转字符串(leetcode_344):

> 将输入的字符串反转过来,字符串以字符数组s的形式给出
> 这道题仍然是双指针,但是发生了变化
>
> 前面的题目都是双指针同向移动遍历, 这道题要反转交换, 双指针需要对向移动遍历
> 对于中间位置的处理
> 如果数组有中间位置,中间位置的值是单一的,不需要交换
> 如果数字没有中间位置,不需要交换
> 那么直接让双指针对向遍历,交换值即可
> 需要注意的是,停止遍历的条件应该是,大指针索引 <= 小指针索引
> 存在中间位置时,是==的情况,没有中间位置时是<的情况
>


最长回文串(leetcode_5):

> 这道题不算复杂,但是思路还是直接记住算了
>
> 回文串的定义不用赘述
> 那如何寻找回文串呢(不是判断,是寻找符合回文串的字符),而且是寻找当前位置为中心最长的回文串
> 方法是:使用双指针,开始同时向两侧背向开始遍历,当出行两个指针的值不同时,停止遍历,已经获得字符就是当前位置为中心最长的回文串
> 这里还涉及到一个问题,就是回文串的中间值处理
> 所以上面的方法要执行两次,一次是双指针从相同位置开始遍历(有中间值场景),另一次是从相邻位置开始遍历(无中间值场景)
> 
> 对于寻找整个字符串中存在的最长回文串,则要整体遍历一遍这个字符串,在遍历到每个位置时,都进行一遍寻找当前位置的最长回文串
> 从所有位置的最长回文串中,找到最长的那个,返回答案
> 



